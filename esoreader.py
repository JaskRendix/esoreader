# This file is licensed under the terms of the MIT license. See the file
# "LICENSE" in the project root for more information.
#
# This module was developed by Daren Thomas at the assistant chair for
# Sustainable Architecture and Building Technologies (Suat) at the Institute of
# Technology in Architecture, ETH Zuerich. See http://suat.arch.ethz.ch for
# more information.

"""
esoreader.py

A python module for reading \*.eso files generated by EnergyPlus

The eso files generated by EnergyPlus contains a data dictionary, which
describes the values reported by EnergyPlus. The list of values reported
depends on the simulation input file, specifically the Output:Variable
objects. EnergyPlus can output the same variable at different
frequencies and for different "keys", which are for instance surfaces or
equipment names.

Following the data dictionary is a list of output variable values for
each of the configured variable coordinates.

The output of the esoreader module is therefore a data dictionary object
that contains a mapping of variable "coordinates" (grouping of reporting
frequency, key and variable name) to the index used by EnergyPlus and a
data object, which essentially just maps that index to the timeseries
data.

This module reads the *.eso file and provides:

- A DataDictionary object: mapping each variable coordinate
  (frequency, key, name) to an internal ID used by EnergyPlus
- A data object: mapping ID → list of time-series values
- An object-oriented interface for exporting results to Pandas

Features
--------
- Search for variables by partial or full name
- Filter by reporting frequency and key
- Export matching results to pandas.DataFrame

Example usage
-------------
Modern (preferred):

    import esoreader
    eso = esoreader.read_from_path("/path/to/eplusout.eso")
    df = eso.to_frame("total heat loss energy")

Legacy:

    import esoreader
    dd, data = esoreader.read("/path/to/eplusout.eso")
    frequency, key, variable = dd.find_variable("Zone Ventilation Total Heat Loss Energy")[0]
    idx = dd.index[(frequency, key, variable)]
    time_series = data[idx]
"""

import json
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import IO, Optional

import pandas as pd


@dataclass
class DataDictionary:
    version: Optional[str] = None
    timestamp: Optional[str] = None

    # ID (int) → [reporting_frequency, key, variable, unit]
    variables: dict[int, list[Optional[str]]] = field(default_factory=dict)

    # (reporting_frequency, key, variable) → ID
    index: dict[tuple[str, Optional[str], str], int] = field(default_factory=dict)

    def build_index(self) -> None:
        """builds a reverse index for finding ids."""
        for id, value in self.variables.items():
            reporting_frequency, key, variable, unit = value
            self.index[(reporting_frequency, key, variable)] = id

    def find_variable(self, search: str) -> list[tuple[str, Optional[str], str]]:
        """returns the coordinates (timestep, key, variable_name) in the
        data dictionary that can be used to find an index. The search is case
        insensitive."""
        return [
            (frequency, key, variable)
            for frequency, key, variable in self.index.keys()
            if search.lower() in variable.lower()
        ]

    def describe(self, max_preview: int = 5) -> None:
        """
        Prints a summary of the data dictionary contents.

        Parameters:
        ----------
        max_preview : int, default=5
            Maximum number of variables to preview per frequency.
        """
        print(f"Data Dictionary — Version: {self.version}, Timestamp: {self.timestamp}")
        print(f"Total Variables: {len(self.variables)}\n")

        grouped: dict[str, list[str]] = {}
        for var_id, (freq, key, varname, unit) in self.variables.items():
            grouped.setdefault(freq, []).append(
                f"{varname} [{key or 'None'}] ({unit or 'no unit'})"
            )

        for freq, vars in grouped.items():
            print(f"- {freq}: {len(vars)} variables")
            for line in vars[:max_preview]:
                print(f"    • {line}")
            if len(vars) > max_preview:
                print(f"    … (+{len(vars) - max_preview} more)\n")
            else:
                print()

    def to_json(self, path: Optional[str] = None, indent: int = 2) -> str:
        """
        Serializes the contents of the data dictionary to a JSON string.

        Parameters:
        ----------
        path : Optional[str], default=None
            If provided, the JSON output will be written to this file path.
            If None, the JSON string is returned.

        indent : int, default=2
            Number of spaces for indentation in the output JSON.

        Returns:
        -------
        str
            A JSON-formatted string representing the data dictionary.
            If `path` is specified, returns the same string after writing to disk.
        """
        summary = {
            "version": self.version,
            "timestamp": self.timestamp,
            "variables": {
                str(var_id): {
                    "reporting_frequency": freq,
                    "key": key,
                    "variable": var,
                    "unit": unit,
                }
                for var_id, (freq, key, var, unit) in self.variables.items()
            },
        }

        json_text = json.dumps(summary, indent=indent)

        if path:
            with open(path, "w") as f:
                f.write(json_text)

        return json_text

    def __repr__(self) -> str:
        summary = (
            f"<DataDictionary version={self.version}, timestamp={self.timestamp}>\n"
        )
        summary += f"  Total variables: {len(self.variables)}\n"
        freqs = set(v[0] for v in self.variables.values() if v[0])
        summary += f"  Reporting frequencies: {', '.join(sorted(freqs))}"
        return summary


class EsoFile:

    def __init__(self, eso_file: IO[str]):
        self.eso_file = eso_file
        self.dd = self._read_data_dictionary()
        self.dd.build_index()
        self.data: dict[int, list[float]] = self._read_data()

    def find_variable(
        self, search: str, key: Optional[str] = None, frequency: str = "TimeStep"
    ) -> list[tuple[str, Optional[str], str]]:
        """
        Finds variable coordinates matching a given name in the ESO data dictionary.

        Parameters:
        ----------
        search : str
            Partial or full name of the variable to search for.
            The search is case-insensitive and supports substring matching.

        key : Optional[str], default=None
            Optional zone or surface name to filter by (e.g. 'Zone1' or 'APARTMENT:ZONE1').
            If None, matches all keys.

        frequency : str, default='TimeStep'
            Desired reporting frequency (e.g. 'Hourly', 'Daily', 'TimeStep').
            Only variables with this frequency will be returned.

        Returns:
        -------
        list[tuple[str, Optional[str], str]]
            A list of coordinate tuples in the form:
            (reporting_frequency, key, variable_name) that match the search criteria.
        """
        matches = self.dd.find_variable(search)
        matches = [m for m in matches if m[0].lower() == frequency.lower()]
        if key:
            matches = [m for m in matches if m[1] and m[1].lower() == key.lower()]
        return matches

    def to_frame(
        self,
        search: str,
        key: Optional[str] = None,
        frequency: str = "TimeStep",
        index: Optional[list] = None,
        use_key_for_columns: bool = True,
    ) -> pd.DataFrame:
        """
        creates a pandas DataFrame objects with a column for every variable
        that matches the search pattern and key. An None key matches all keys.
        NOTE: The frequency *has* to be the same for all variables selected.
        (uses find_variable to select the variables)
        """
        variables = self.find_variable(search, key=key, frequency=frequency)
        if use_key_for_columns:
            columns = {v[1]: self.data[self.dd.index[v]] for v in variables}
        else:
            columns = {v[2]: self.data[self.dd.index[v]] for v in variables}
        df = pd.DataFrame(columns)
        if index is not None:
            df.index = index
        return df

    @staticmethod
    def _read_reporting_frequency(line: str) -> tuple[str, Optional[str]]:
        core = line.strip()
        frequency = None

        if "!" in core:
            parts = core.partition("!")
            core = parts[0].strip()
            frequency = parts[1].split()[0].strip()  # Just the keyword, e.g. "Hourly"

        return core, frequency

    @staticmethod
    def _read_variable_unit(variable: str) -> tuple[str, Optional[str]]:
        match = re.match(r"^(.*?)\s*\[(.+?)\]$", variable.strip())
        if match:
            return match.group(1).strip(), match.group(2).strip()
        return variable.strip(), None

    def _read_data_dictionary(self) -> DataDictionary:
        """parses the head of the eso_file, returning the data dictionary.
        the file object eso_file is advanced to the position needed by
        read_data.
        """
        # Extract version and timestamp from header
        header_line = self.eso_file.readline()
        parts = [part.strip() for part in header_line.split(",")]

        try:
            version, timestamp = parts[-2], parts[-1]
        except IndexError:
            raise ValueError(f"Header line malformed: '{header_line}'")

        dd = DataDictionary(version=version, timestamp=timestamp)

        for line in self.eso_file:
            line = line.strip()
            if line == "End of Data Dictionary":
                break

            core_line, frequency = self._read_reporting_frequency(line)
            if not frequency:
                continue  # skip irrelevant lines

            fields = [f.strip() for f in core_line.split(",")]
            if len(fields) >= 4:
                var_id, _, key, raw_variable = fields[:4]
            else:
                var_id, _, raw_variable = fields[:3]
                key = None

            variable, unit = self._read_variable_unit(raw_variable)
            dd.variables[int(var_id)] = [frequency, key, variable, unit]

        dd.ids = set(dd.variables.keys())
        return dd

    def _read_data(self) -> dict[int, list[float]]:
        """parse the data from the .eso file returning,
        NOTE: eso_file should be the same file object that was passed to
        read_data_dictionary(eso_file) to obtain dd."""
        data: dict[int, list[float]] = {id: [] for id in self.dd.variables}

        for line in self.eso_file:
            if line.strip() == "End of Data":
                break

            fields = [field.strip() for field in line.split(",")]
            if len(fields) < 2:
                continue  # Malformed line

            try:
                var_id = int(fields[0])
                value = float(fields[1])
            except (ValueError, IndexError):
                continue  # Skip corrupted or non-data rows

            if var_id in data:
                data[var_id].append(value)

        return data


def read(eso_file_path: str) -> tuple[DataDictionary, dict[int, list[float]]]:
    """Read in an .eso file and return the data dictionary and a dictionary
    representing the data.
    NOTE: this function is here for backward compatibilty reasons. Use
    read_from_path() instead to obtain an EsoFile object.
    """
    eso = read_from_path(eso_file_path)
    return eso.dd, eso.data


def read_from_path(eso_file_path: str) -> EsoFile:
    """
    read in a .eso file and return an EsoFile object that can be used
    to read in pandas DataFrame and Series objects.
    """
    path = Path(eso_file_path)
    with path.open("r") as eso_file:
        return EsoFile(eso_file)


def explore_eso_variables(
    eso_path: str, frequency_filter: Optional[str] = None, preview_count: int = 5
) -> None:
    """
    Prints a summary of available output variables in an EnergyPlus .eso file,
    including their reporting frequency, key (if any), and a preview of time series values.

    Parameters:
    ----------
    eso_path : str
        The file path to the EnergyPlus .eso output file.

    frequency_filter : Optional[str], default=None
        Limits the output to variables with a specific reporting frequency
        (e.g. "Hourly", "TimeStep", "Daily"). If None, includes all frequencies.

    preview_count : int, default=5
        Number of data points to preview for each variable.
    """
    eso = read_from_path(eso_path)
    print(f"ESO Version: {eso.dd.version}, Timestamp: {eso.dd.timestamp}")
    print("Available Variables:\n")

    for (freq, key, varname), var_id in eso.dd.index.items():
        if frequency_filter and freq.lower() != frequency_filter.lower():
            continue

        values = eso.data.get(var_id, [])
        preview = values[:preview_count]
        print(f"- [{freq}] Key: {key or 'None'}, Variable: {varname}")
        print(f"  → Preview: {preview}\n")


def get_zone_variable_series(
    eso_path: str, variable: str, key_filter: str, frequency: str = "Hourly"
) -> Optional[list[float]]:
    """
    Retrieves the time series data for a specific EnergyPlus variable reported for a given zone (key).

    Parameters:
    ----------
    eso_path : str
        Path to the eplusout.eso file.

    variable : str
        Partial or full name of the variable to search (e.g. 'Zone Air Temperature').

    key_filter : str
        Exact name of the zone or surface to filter by (e.g. 'APARTMENT:ZONE1').

    frequency : str, default='Hourly'
        Desired reporting frequency ('Hourly', 'TimeStep', etc.).

    Returns:
    -------
    Optional[list[float]]
        The time series data for the matching variable and key, or None if not found.
    """
    eso = read_from_path(eso_path)
    matches = eso.find_variable(variable, key=key_filter, frequency=frequency)

    if not matches:
        print(
            f"Variable '{variable}' not found for key '{key_filter}' with frequency '{frequency}'."
        )
        return None

    idx = eso.dd.index[matches[0]]
    return eso.data[idx]
